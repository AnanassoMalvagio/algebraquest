<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Algebra Quest</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #f4e4bc;
            overflow: hidden;
        }
        
        .game-container {
            display: flex;
            height: 100vh;
        }
        
        .game-area {
            flex: 1;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            background: rgba(0, 0, 0, 0.5);
            border: 3px solid #ffd700;
            margin: 10px;
            border-radius: 10px;
        }
        
        #gameCanvas {
            display: block;
            background: #1a1a1a;
            border: 2px solid #444;
            border-radius: 5px;
        }
        
        .sidebar {
            width: 350px;
            background: rgba(20, 20, 30, 0.95);
            border-left: 3px solid #ffd700;
            padding: 20px;
            box-shadow: inset 5px 0 15px rgba(0,0,0,0.5);
            overflow-y: auto;
        }
        
        .title {
            text-align: center;
            font-size: 28px;
            color: #ffd700;
            text-shadow: 2px 2px 4px #000;
            margin-bottom: 20px;
            border-bottom: 2px solid #ffd700;
            padding-bottom: 10px;
            font-weight: bold;
        }
        
        .stats {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 10px 0;
            font-size: 16px;
        }
        
        .stat-value {
            color: #ffd700;
            font-weight: bold;
        }
        
        .health-bar, .mana-bar {
            width: 100%;
            height: 25px;
            background: #333;
            border: 2px solid #666;
            border-radius: 12px;
            overflow: hidden;
            margin: 8px 0;
            position: relative;
        }
        
        .health-fill {
            height: 100%;
            background: linear-gradient(to right, #ff4444, #ff6666);
            transition: width 0.3s ease;
        }
        
        .mana-fill {
            height: 100%;
            background: linear-gradient(to right, #4444ff, #6666ff);
            transition: width 0.3s ease;
        }
        
        .bar-text {
            position: absolute;
            width: 100%;
            text-align: center;
            line-height: 25px;
            color: white;
            font-weight: bold;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.8);
        }
        
        .equation-panel {
            background: linear-gradient(135deg, rgba(0, 0, 50, 0.9), rgba(0, 0, 100, 0.9));
            border: 3px solid #4169e1;
            border-radius: 15px;
            padding: 25px;
            margin: 15px 0;
            display: none;
            text-align: center;
            box-shadow: 0 0 30px rgba(65, 105, 225, 0.6);
            animation: glow 2s ease-in-out infinite;
        }
        
        @keyframes glow {
            0%, 100% { box-shadow: 0 0 30px rgba(65, 105, 225, 0.6); }
            50% { box-shadow: 0 0 40px rgba(65, 105, 225, 0.8); }
        }
        
        .equation-text {
            font-size: 28px;
            color: #87ceeb;
            margin: 20px 0;
            font-family: 'Courier New', monospace;
            font-weight: bold;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.5);
        }
        
        .answer-input {
            width: 100px;
            padding: 12px;
            font-size: 20px;
            text-align: center;
            border: 2px solid #4169e1;
            border-radius: 8px;
            background: #001122;
            color: #fff;
            margin: 10px 5px;
            font-weight: bold;
        }
        
        .submit-btn {
            background: linear-gradient(135deg, #4169e1, #5a7bd4);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 16px;
            margin: 10px 5px;
            transition: all 0.3s;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .submit-btn:hover {
            background: linear-gradient(135deg, #5a7bd4, #6b8ce5);
            transform: scale(1.05);
            box-shadow: 0 5px 15px rgba(65, 105, 225, 0.4);
        }
        
        .controls {
            background: rgba(255, 215, 0, 0.1);
            border: 2px solid #ffd700;
            border-radius: 10px;
            padding: 15px;
            margin: 15px 0;
            font-size: 14px;
            line-height: 1.8;
        }
        
        .message-log {
            background: rgba(0, 0, 0, 0.8);
            border: 2px solid #666;
            border-radius: 10px;
            padding: 15px;
            height: 180px;
            overflow-y: auto;
            font-size: 14px;
            line-height: 1.6;
        }
        
        .message {
            margin: 5px 0;
            padding: 8px;
            border-radius: 5px;
            animation: slideIn 0.3s ease;
        }
        
        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }
        
        .message.success {
            background: rgba(0, 255, 0, 0.2);
            color: #90ee90;
            border-left: 4px solid #90ee90;
        }
        
        .message.error {
            background: rgba(255, 0, 0, 0.2);
            color: #ffcccb;
            border-left: 4px solid #ff6666;
        }
        
        .message.info {
            background: rgba(0, 100, 255, 0.2);
            color: #add8e6;
            border-left: 4px solid #4169e1;
        }
        
        .screen-overlay {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: linear-gradient(135deg, rgba(0, 0, 0, 0.95), rgba(20, 20, 40, 0.95));
            border: 3px solid #ffd700;
            border-radius: 20px;
            padding: 50px;
            text-align: center;
            display: none;
            z-index: 1000;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.3);
        }
        
        .screen-overlay h2 {
            font-size: 36px;
            margin-top: 0;
            text-shadow: 3px 3px 6px rgba(0,0,0,0.5);
        }
        
        .victory-screen h2 {
            color: #ffd700;
        }
        
        .game-over-screen h2 {
            color: #ff4444;
        }
        
        .restart-btn {
            background: linear-gradient(135deg, #ffd700, #ffed4e);
            color: #1a1a2e;
            border: none;
            padding: 15px 40px;
            font-size: 18px;
            border-radius: 10px;
            cursor: pointer;
            margin-top: 20px;
            transition: all 0.3s;
            font-weight: bold;
            text-transform: uppercase;
        }
        
        .restart-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 10px 25px rgba(255, 215, 0, 0.4);
        }
        
        .loading {
            text-align: center;
            font-size: 24px;
            color: #ffd700;
            padding: 50px;
        }
    </style>
</head>
<body>
    <div class="game-container">
        <div class="game-area">
            <canvas id="gameCanvas" width="600" height="600"></canvas>
            <div id="loadingScreen" class="loading" style="position: absolute;">
                üéÆ Caricamento Algebra Quest...
            </div>
        </div>
        
        <div class="sidebar">
            <div class="title">üè∞ ALGEBRA QUEST üè∞</div>
            
            <div class="stats">
                <div class="stat-item">
                    <span>‚≠ê Livello:</span>
                    <span class="stat-value" id="level">1</span>
                </div>
                <div class="stat-item">
                    <span>‚ú® Esperienza:</span>
                    <span class="stat-value" id="exp">0/100</span>
                </div>
                <div class="stat-item">
                    <span>üìç Stanza:</span>
                    <span class="stat-value" id="room">1</span>
                </div>
                
                <div style="margin: 15px 0;">
                    <div style="margin-bottom: 5px;">‚ù§Ô∏è Salute</div>
                    <div class="health-bar">
                        <div class="bar-text" id="healthText">100/100</div>
                        <div class="health-fill" id="healthFill" style="width: 100%"></div>
                    </div>
                </div>
                
                <div style="margin: 15px 0;">
                    <div style="margin-bottom: 5px;">üíô Mana</div>
                    <div class="mana-bar">
                        <div class="bar-text" id="manaText">50/50</div>
                        <div class="mana-fill" id="manaFill" style="width: 100%"></div>
                    </div>
                </div>
            </div>
            
            <div class="equation-panel" id="equationPanel">
                <h3 style="color: #87ceeb; margin-top: 0;">üßÆ SFIDA MATEMATICA!</h3>
                <div class="equation-text" id="equationText">2x + 5 = 13</div>
                <div>
                    <span style="color: #87ceeb; font-size: 20px; font-weight: bold;">x = </span>
                    <input type="number" class="answer-input" id="answerInput" placeholder="?">
                </div>
                <button class="submit-btn" onclick="checkAnswer()">‚úÖ Risolvi</button>
                <button class="submit-btn" onclick="skipEquation()" style="background: linear-gradient(135deg, #666, #888);">‚è≠Ô∏è Salta (-10 Mana)</button>
            </div>
            
            <div class="controls">
                <strong>üéÆ CONTROLLI:</strong><br>
                <b>WASD / Frecce:</b> Muovi il personaggio<br><br>
                
                <strong>üéØ COME GIOCARE:</strong><br>
                ‚Ä¢ üö∂ Avvicinati agli oggetti colorati<br>
                ‚Ä¢ ‚ö° L'interazione parte automaticamente<br>
                ‚Ä¢ üßÆ Risolvi l'equazione per procedere<br>
                ‚Ä¢ üí° Non serve premere SPAZIO!<br><br>
                
                <strong>üìç OGGETTI NEL DUNGEON:</strong><br>
                ‚Ä¢ üö™ <span style="color: #3b82f6;">Porte blu</span> - Bloccano il passaggio<br>
                ‚Ä¢ üëπ <span style="color: #ef4444;">Nemici rossi</span> - Ti sfidano<br>
                ‚Ä¢ üí∞ <span style="color: #fbbf24;">Tesori dorati</span> - Bonus salute<br>
                ‚Ä¢ üèÜ <span style="color: #4ade80;">Uscita verde</span> - Obiettivo finale<br><br>
                
                <strong>üí° SUGGERIMENTI:</strong><br>
                ‚Ä¢ Quando ti avvicini, parte la sfida<br>
                ‚Ä¢ Puoi saltare con il mana se √® troppo difficile<br>
                ‚Ä¢ Guarda la minimappa per orientarti
            </div>
            
            <div class="message-log" id="messageLog">
                <div class="message info">üåü Benvenuto in Algebra Quest!</div>
                <div class="message info">üéÆ Usa WASD o le frecce per muoverti</div>
                <div class="message info">üö™ Avvicinati agli oggetti e premi SPAZIO</div>
            </div>
        </div>
    </div>
    
    <div class="screen-overlay victory-screen" id="victoryScreen">
        <h2>üèÜ VITTORIA! üèÜ</h2>
        <div style="font-size: 20px; margin: 30px 0;">
            Complimenti! Hai completato il dungeon!<br><br>
            Livello finale: <span id="finalLevel" style="color: #ffd700; font-weight: bold;">1</span><br>
            Esperienza totale: <span id="finalExp" style="color: #ffd700; font-weight: bold;">0</span><br><br>
            Sei un vero maestro dell'algebra!
        </div>
        <button class="restart-btn" onclick="restartGame()">üéÆ Nuova Avventura</button>
    </div>
    
    <div class="screen-overlay game-over-screen" id="gameOverScreen">
        <h2>üíÄ GAME OVER üíÄ</h2>
        <div style="font-size: 18px; margin: 30px 0; color: #ff9999;">
            La tua avventura √® terminata!<br>
            Le equazioni hanno avuto la meglio...<br><br>
            Non arrenderti! Riprova!
        </div>
        <button class="restart-btn" onclick="restartGame()">üîÑ Riprova</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');
        const loadingScreen = document.getElementById('loadingScreen');
        
        // Costanti del gioco
        const TILE_SIZE = 30;
        const MAP_WIDTH = 20;
        const MAP_HEIGHT = 20;
        
        // Tipi di celle
        const CELL_TYPES = {
            WALL: 0,
            FLOOR: 1,
            DOOR: 2,
            ENEMY: 3,
            TREASURE: 4,
            EXIT: 5
        };
        
        // Stato del giocatore
        let player = {
            x: 1,
            y: 1,
            health: 100,
            maxHealth: 100,
            mana: 50,
            maxMana: 50,
            level: 1,
            exp: 0,
            expToNext: 100,
            color: '#00ffff'
        };
        
        // Stato del gioco
        let gameState = {
            currentRoom: 1,
            currentEquation: null,
            awaitingAnswer: false,
            gameRunning: true,
            initialized: false
        };
        
        // Mappa e entit√†
        let gameMap = [];
        let entities = [];
        
        // Generatore di equazioni con difficolt√† crescente
        function generateEquation() {
            const difficulty = Math.min(player.level, 5);
            let equation = {};
            
            switch(Math.floor(Math.random() * difficulty) + 1) {
                case 1: // Equazioni lineari semplici
                    const a1 = Math.floor(Math.random() * 5) + 2;
                    const b1 = Math.floor(Math.random() * 10) + 1;
                    const x1 = Math.floor(Math.random() * 10) + 1;
                    equation = {
                        text: `${a1}x + ${b1} = ${a1 * x1 + b1}`,
                        answer: x1,
                        difficulty: 1
                    };
                    break;
                    
                case 2: // Equazioni con sottrazione
                    const a2 = Math.floor(Math.random() * 7) + 3;
                    const b2 = Math.floor(Math.random() * 15) + 5;
                    const x2 = Math.floor(Math.random() * 8) + 2;
                    equation = {
                        text: `${a2}x - ${b2} = ${a2 * x2 - b2}`,
                        answer: x2,
                        difficulty: 2
                    };
                    break;
                    
                case 3: // Equazioni con entrambi i membri
                    const a3 = Math.floor(Math.random() * 5) + 2;
                    const b3 = Math.floor(Math.random() * 10) + 1;
                    const c3 = Math.floor(Math.random() * 5) + 1;
                    const x3 = Math.floor(Math.random() * 10) + 1;
                    equation = {
                        text: `${a3}x + ${b3} = ${c3}x + ${a3 * x3 + b3 - c3 * x3}`,
                        answer: x3,
                        difficulty: 3
                    };
                    break;
                    
                case 4: // Equazioni con parentesi
                    const a4 = Math.floor(Math.random() * 4) + 2;
                    const x4 = Math.floor(Math.random() * 8) + 1;
                    const result4 = a4 * (x4 + 3);
                    equation = {
                        text: `${a4}(x + 3) = ${result4}`,
                        answer: x4,
                        difficulty: 4
                    };
                    break;
                    
                case 5: // Equazioni quadratiche semplici
                    const x5 = Math.floor(Math.random() * 6) + 2;
                    equation = {
                        text: `x¬≤ = ${x5 * x5}`,
                        answer: x5,
                        difficulty: 5
                    };
                    break;
                    
                default:
                    const ax = Math.floor(Math.random() * 5) + 1;
                    const bx = Math.floor(Math.random() * 10) + 1;
                    const xx = Math.floor(Math.random() * 10) + 1;
                    equation = {
                        text: `${ax}x + ${bx} = ${ax * xx + bx}`,
                        answer: xx,
                        difficulty: 1
                    };
            }
            
            return equation;
        }
        
        // Genera la mappa del dungeon
        function generateMap() {
            // Inizializza con muri
            gameMap = [];
            for (let y = 0; y < MAP_HEIGHT; y++) {
                gameMap[y] = [];
                for (let x = 0; x < MAP_WIDTH; x++) {
                    gameMap[y][x] = CELL_TYPES.WALL;
                }
            }
            
            // Crea stanze pi√π grandi e accessibili
            const rooms = [
                {x: 1, y: 1, w: 7, h: 7},     // Stanza iniziale
                {x: 10, y: 2, w: 8, h: 6},    // Stanza destra alta
                {x: 2, y: 10, w: 6, h: 7},    // Stanza sinistra bassa
                {x: 11, y: 11, w: 7, h: 7},   // Stanza destra bassa
            ];
            
            // Scava le stanze
            rooms.forEach(room => {
                for (let y = room.y; y < Math.min(room.y + room.h, MAP_HEIGHT - 1); y++) {
                    for (let x = room.x; x < Math.min(room.x + room.w, MAP_WIDTH - 1); x++) {
                        gameMap[y][x] = CELL_TYPES.FLOOR;
                    }
                }
            });
            
            // Crea corridoi pi√π larghi
            createCorridor(8, 3, 10, 3);  // Corridoio orizzontale alto
            createCorridor(8, 4, 10, 4);  // Rendi il corridoio pi√π largo
            createCorridor(4, 8, 4, 10);  // Corridoio verticale sinistra
            createCorridor(5, 8, 5, 10);  // Pi√π largo
            createCorridor(8, 13, 11, 13); // Corridoio orizzontale basso
            createCorridor(8, 14, 11, 14); // Pi√π largo
            createCorridor(14, 8, 14, 11); // Corridoio verticale destra
            
            // Posiziona entit√† in posizioni accessibili
            entities = [];
            
            // Aggiungi entit√† garantendo che siano su pavimento
            const entityPositions = [
                {x: 6, y: 3, type: CELL_TYPES.DOOR},      // Prima porta nella stanza iniziale
                {x: 13, y: 4, type: CELL_TYPES.TREASURE}, // Tesoro nella seconda stanza
                {x: 4, y: 13, type: CELL_TYPES.ENEMY},    // Nemico nella terza stanza
                {x: 14, y: 14, type: CELL_TYPES.DOOR},    // Seconda porta
                {x: 15, y: 15, type: CELL_TYPES.EXIT}     // Uscita finale
            ];
            
            entityPositions.forEach(pos => {
                // Verifica che la posizione sia su pavimento
                if (gameMap[pos.y] && gameMap[pos.y][pos.x] === CELL_TYPES.FLOOR) {
                    entities.push({
                        x: pos.x,
                        y: pos.y,
                        type: pos.type,
                        solved: false,
                        proximityShown: false
                    });
                    console.log(`Entit√† creata: tipo ${pos.type} a posizione (${pos.x}, ${pos.y})`);
                }
            });
            
            // Posizione iniziale del giocatore
            player.x = 2;
            player.y = 2;
            
            console.log('Mappa generata. Entit√† totali:', entities.length);
        }
        
        // Crea un corridoio tra due punti
        function createCorridor(x1, y1, x2, y2) {
            let x = x1, y = y1;
            
            // Movimento orizzontale
            while (x !== x2) {
                if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
                    gameMap[y][x] = CELL_TYPES.FLOOR;
                }
                x += x2 > x1 ? 1 : -1;
            }
            
            // Movimento verticale
            while (y !== y2) {
                if (x >= 0 && x < MAP_WIDTH && y >= 0 && y < MAP_HEIGHT) {
                    gameMap[y][x] = CELL_TYPES.FLOOR;
                }
                y += y2 > y1 ? 1 : -1;
            }
            
            // Assicura che il punto finale sia percorribile
            if (x2 >= 0 && x2 < MAP_WIDTH && y2 >= 0 && y2 < MAP_HEIGHT) {
                gameMap[y2][x2] = CELL_TYPES.FLOOR;
            }
        }
        
        // Nuova funzione per interazioni di prossimit√†
        function checkProximityInteractions() {
            // Debug per vedere se la funzione viene chiamata
            console.log('Controllo prossimit√†. Posizione giocatore:', player.x, player.y);
            console.log('Entit√† nel gioco:', entities);
            
            // Controlla se il giocatore √® vicino a un'entit√†
            entities.forEach(entity => {
                if (!entity.solved && !gameState.awaitingAnswer) {
                    const distance = Math.abs(entity.x - player.x) + Math.abs(entity.y - player.y);
                    
                    console.log(`Distanza da entit√† tipo ${entity.type} a (${entity.x},${entity.y}): ${distance}`);
                    
                    // Se sei a distanza 0 (sopra) o 1 (adiacente) dall'entit√†
                    if (distance <= 1) {
                        // Mostra un messaggio di prossimit√†
                        if (!entity.proximityShown) {
                            let proximityMsg = '';
                            switch(entity.type) {
                                case CELL_TYPES.DOOR:
                                    proximityMsg = 'üö™ Ti avvicini a una porta bloccata...';
                                    break;
                                case CELL_TYPES.ENEMY:
                                    proximityMsg = '‚öîÔ∏è Un nemico ti nota!';
                                    break;
                                case CELL_TYPES.TREASURE:
                                    proximityMsg = 'üí∞ Hai trovato un tesoro!';
                                    break;
                                case CELL_TYPES.EXIT:
                                    proximityMsg = 'üèÜ L\'uscita √® vicina!';
                                    break;
                            }
                            addMessage(proximityMsg, 'info');
                            entity.proximityShown = true;
                            
                            // Attiva automaticamente l'interazione dopo un breve ritardo
                            console.log('Attivando interazione per entit√†:', entity);
                            setTimeout(() => {
                                if (!gameState.awaitingAnswer && !entity.solved) {
                                    const currentDistance = Math.abs(entity.x - player.x) + Math.abs(entity.y - player.y);
                                    if (currentDistance <= 1) {
                                        console.log('Chiamando handleEntityInteraction');
                                        handleEntityInteraction(entity);
                                    }
                                }
                            }, 500);
                        }
                    } else {
                        // Reset il flag quando ti allontani
                        entity.proximityShown = false;
                    }
                }
            });
        }
        
        // Muovi il giocatore
        function movePlayer(dx, dy) {
            if (!gameState.gameRunning || gameState.awaitingAnswer) return;
            
            const newX = player.x + dx;
            const newY = player.y + dy;
            
            // Controlla i limiti della mappa
            if (newX < 0 || newX >= MAP_WIDTH || newY < 0 || newY >= MAP_HEIGHT) return;
            
            // Controlla collisione con i muri
            if (gameMap[newY][newX] === CELL_TYPES.WALL) return;
            
            // Muovi il giocatore
            player.x = newX;
            player.y = newY;
            
            console.log('Giocatore mosso a:', player.x, player.y);
            
            // Controlla automaticamente interazioni quando arrivi vicino a un'entit√†
            checkProximityInteractions();
        }
        
        // Rimuovi o modifica la funzione checkInteractions per non usare SPAZIO
        function checkInteractions() {
            // Questa funzione ora √® vuota o pu√≤ essere usata per altri scopi
            // L'interazione avviene automaticamente con checkProximityInteractions
            addMessage('üí° Avvicinati agli oggetti per interagire automaticamente!', 'info');
        }
        
        // Gestisce l'interazione con un'entit√†
        function handleEntityInteraction(entity) {
            let message = '';
            switch(entity.type) {
                case CELL_TYPES.DOOR:
                    message = 'üö™ Una porta bloccata! Risolvi per aprirla!';
                    break;
                case CELL_TYPES.ENEMY:
                    message = '‚öîÔ∏è Un nemico ti sfida! Risolvi per sconfiggerlo!';
                    break;
                case CELL_TYPES.TREASURE:
                    message = 'üí∞ Un tesoro! Risolvi per ottenerlo!';
                    break;
                case CELL_TYPES.EXIT:
                    message = 'üèÜ L\'uscita! Un\'ultima sfida ti attende!';
                    break;
            }
            
            addMessage(message, 'info');
            showEquation(entity);
        }
        
        // Mostra il pannello dell'equazione
        function showEquation(entity) {
            // Previeni equazioni multiple
            if (gameState.awaitingAnswer) return;
            
            gameState.currentEquation = generateEquation();
            gameState.currentEquation.entity = entity;
            
            console.log('Mostrando equazione:', gameState.currentEquation);
            
            document.getElementById('equationText').textContent = gameState.currentEquation.text;
            document.getElementById('answerInput').value = '';
            document.getElementById('equationPanel').style.display = 'block';
            
            // Focus dopo un piccolo delay per assicurare che il pannello sia visibile
            setTimeout(() => {
                document.getElementById('answerInput').focus();
            }, 100);
            
            gameState.awaitingAnswer = true;
        }
        
        // Controlla la risposta
        function checkAnswer() {
            const userAnswer = parseInt(document.getElementById('answerInput').value);
            const correctAnswer = gameState.currentEquation.answer;
            
            if (userAnswer === correctAnswer) {
                handleCorrectAnswer();
            } else {
                handleWrongAnswer();
            }
        }
        
        // Gestisce risposta corretta
        function handleCorrectAnswer() {
            const entity = gameState.currentEquation.entity;
            entity.solved = true;
            
            const expGain = gameState.currentEquation.difficulty * 25;
            player.exp += expGain;
            
            let message = '';
            switch(entity.type) {
                case CELL_TYPES.DOOR:
                    message = `‚úÖ Porta aperta! +${expGain} EXP`;
                    break;
                case CELL_TYPES.ENEMY:
                    message = `‚öîÔ∏è Nemico sconfitto! +${expGain} EXP +10 Mana`;
                    player.mana = Math.min(player.maxMana, player.mana + 10);
                    break;
                case CELL_TYPES.TREASURE:
                    message = `üí∞ Tesoro ottenuto! +${expGain} EXP +25 Salute`;
                    player.health = Math.min(player.maxHealth, player.health + 25);
                    break;
                case CELL_TYPES.EXIT:
                    message = `üèÜ Vittoria! Hai completato il livello!`;
                    setTimeout(showVictory, 1000);
                    break;
            }
            
            addMessage(message, 'success');
            checkLevelUp();
            hideEquation();
        }
        
        // Gestisce risposta sbagliata
        function handleWrongAnswer() {
            player.health -= 10;
            addMessage(`‚ùå Risposta errata! -10 Salute`, 'error');
            
            if (player.health <= 0) {
                gameOver();
            }
        }
        
        // Salta l'equazione usando mana
        function skipEquation() {
            if (player.mana >= 10) {
                player.mana -= 10;
                gameState.currentEquation.entity.solved = true;
                addMessage('‚è≠Ô∏è Enigma saltato con la magia! -10 Mana', 'info');
                hideEquation();
            } else {
                addMessage('‚ùå Mana insufficiente!', 'error');
            }
        }
        
        // Nasconde il pannello dell'equazione
        function hideEquation() {
            document.getElementById('equationPanel').style.display = 'none';
            gameState.awaitingAnswer = false;
            gameState.currentEquation = null;
        }
        
        // Controlla level up
        function checkLevelUp() {
            while (player.exp >= player.expToNext) {
                player.exp -= player.expToNext;
                player.level++;
                player.expToNext = 100 + (player.level - 1) * 50;
                player.maxHealth += 20;
                player.maxMana += 10;
                player.health = player.maxHealth;
                player.mana = player.maxMana;
                
                addMessage(`üéâ LEVEL UP! Ora sei livello ${player.level}!`, 'success');
            }
        }
        
        // Aggiorna l'interfaccia
        function updateUI() {
            document.getElementById('level').textContent = player.level;
            document.getElementById('exp').textContent = `${player.exp}/${player.expToNext}`;
            document.getElementById('room').textContent = gameState.currentRoom;
            document.getElementById('healthText').textContent = `${player.health}/${player.maxHealth}`;
            document.getElementById('manaText').textContent = `${player.mana}/${player.maxMana}`;
            
            document.getElementById('healthFill').style.width = `${(player.health / player.maxHealth) * 100}%`;
            document.getElementById('manaFill').style.width = `${(player.mana / player.maxMana) * 100}%`;
        }
        
        // Funzione di rendering principale
        function draw() {
            // Pulisce il canvas
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Calcola la vista centrata sul giocatore
            const viewportX = Math.floor(canvas.width / TILE_SIZE);
            const viewportY = Math.floor(canvas.height / TILE_SIZE);
            const offsetX = Math.max(0, Math.min(MAP_WIDTH - viewportX, player.x - Math.floor(viewportX / 2)));
            const offsetY = Math.max(0, Math.min(MAP_HEIGHT - viewportY, player.y - Math.floor(viewportY / 2)));
            
            // Disegna la mappa
            for (let y = 0; y < viewportY; y++) {
                for (let x = 0; x < viewportX; x++) {
                    const mapX = offsetX + x;
                    const mapY = offsetY + y;
                    
                    if (mapX >= 0 && mapX < MAP_WIDTH && mapY >= 0 && mapY < MAP_HEIGHT) {
                        drawTile(x * TILE_SIZE, y * TILE_SIZE, gameMap[mapY][mapX]);
                    }
                }
            }
            
            // Disegna le entit√†
            entities.forEach(entity => {
                if (!entity.solved) {
                    const screenX = (entity.x - offsetX) * TILE_SIZE;
                    const screenY = (entity.y - offsetY) * TILE_SIZE;
                    
                    if (screenX >= 0 && screenX < canvas.width && screenY >= 0 && screenY < canvas.height) {
                        drawEntity(screenX, screenY, entity.type);
                    }
                }
            });
            
            // Disegna il giocatore
            const playerScreenX = (player.x - offsetX) * TILE_SIZE;
            const playerScreenY = (player.y - offsetY) * TILE_SIZE;
            drawPlayer(playerScreenX, playerScreenY);
            
            // Disegna la minimappa
            drawMinimap();
        }
        
        // Disegna una singola cella
        function drawTile(x, y, type) {
            switch(type) {
                case CELL_TYPES.WALL:
                    // Muro con gradiente
                    const gradient = ctx.createLinearGradient(x, y, x, y + TILE_SIZE);
                    gradient.addColorStop(0, '#444');
                    gradient.addColorStop(1, '#222');
                    ctx.fillStyle = gradient;
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    
                    // Bordo del muro
                    ctx.strokeStyle = '#555';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
                    break;
                    
                case CELL_TYPES.FLOOR:
                    // Pavimento con pattern
                    ctx.fillStyle = '#1a1a1a';
                    ctx.fillRect(x, y, TILE_SIZE, TILE_SIZE);
                    
                    // Griglia sottile
                    ctx.strokeStyle = '#2a2a2a';
                    ctx.lineWidth = 0.5;
                    ctx.strokeRect(x, y, TILE_SIZE, TILE_SIZE);
                    break;
            }
        }
        
        // Disegna un'entit√†
        function drawEntity(x, y, type) {
            ctx.save();
            
            // Aggiungi un'aura pulsante per indicare che √® interagibile
            if (!gameState.awaitingAnswer) {
                const pulse = Math.sin(Date.now() / 300) * 0.3 + 0.7;
                ctx.globalAlpha = pulse;
            }
            
            switch(type) {
                case CELL_TYPES.DOOR:
                    // Porta blu con effetto luminoso
                    ctx.shadowColor = '#3b82f6';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#1e3a8a';
                    ctx.fillRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                    ctx.strokeStyle = '#3b82f6';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                    
                    // Simbolo porta
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#60a5fa';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üö™', x + TILE_SIZE/2, y + TILE_SIZE/2);
                    break;
                    
                case CELL_TYPES.ENEMY:
                    // Nemico rosso con effetto luminoso
                    ctx.shadowColor = '#ef4444';
                    ctx.shadowBlur = 10;
                    ctx.fillStyle = '#7f1d1d';
                    ctx.fillRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                    ctx.strokeStyle = '#ef4444';
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x + 2, y + 2, TILE_SIZE - 4, TILE_SIZE - 4);
                    
                    // Simbolo nemico
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#f87171';
                    ctx.font = '18px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üëπ', x + TILE_SIZE/2, y + TILE_SIZE/2);
                    break;
                    
                case CELL_TYPES.TREASURE:
                    // Tesoro dorato con effetto scintillante
                    ctx.shadowColor = '#fbbf24';
                    ctx.shadowBlur = 15;
                    const treasureGradient = ctx.createRadialGradient(
                        x + TILE_SIZE/2, y + TILE_SIZE/2, 0,
                        x + TILE_SIZE/2, y + TILE_SIZE/2, TILE_SIZE/2
                    );
                    treasureGradient.addColorStop(0, '#fbbf24');
                    treasureGradient.addColorStop(1, '#d97706');
                    ctx.fillStyle = treasureGradient;
                    ctx.fillRect(x + 3, y + 3, TILE_SIZE - 6, TILE_SIZE - 6);
                    
                    // Simbolo tesoro
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#fef3c7';
                    ctx.font = '18px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üí∞', x + TILE_SIZE/2, y + TILE_SIZE/2);
                    break;
                    
                case CELL_TYPES.EXIT:
                    // Uscita verde con effetto luminoso
                    ctx.shadowColor = '#4ade80';
                    ctx.shadowBlur = 20;
                    const exitGradient = ctx.createRadialGradient(
                        x + TILE_SIZE/2, y + TILE_SIZE/2, 0,
                        x + TILE_SIZE/2, y + TILE_SIZE/2, TILE_SIZE/2
                    );
                    exitGradient.addColorStop(0, '#4ade80');
                    exitGradient.addColorStop(1, '#16a34a');
                    ctx.fillStyle = exitGradient;
                    ctx.fillRect(x + 1, y + 1, TILE_SIZE - 2, TILE_SIZE - 2);
                    
                    // Simbolo uscita
                    ctx.globalAlpha = 1;
                    ctx.fillStyle = '#f0fdf4';
                    ctx.font = '20px Arial';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText('üèÜ', x + TILE_SIZE/2, y + TILE_SIZE/2);
                    break;
            }
            
            ctx.restore();
        }
        
        // Disegna il giocatore
        function drawPlayer(x, y) {
            ctx.save();
            
            // Effetto glow attorno al giocatore
            ctx.shadowColor = player.color;
            ctx.shadowBlur = 10;
            
            // Corpo del giocatore
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.arc(x + TILE_SIZE/2, y + TILE_SIZE/2, TILE_SIZE/3, 0, Math.PI * 2);
            ctx.fill();
            
            // Bordo
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.stroke();
            
            // Simbolo del giocatore
            ctx.fillStyle = '#000';
            ctx.font = 'bold 14px Arial';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText('‚öî', x + TILE_SIZE/2, y + TILE_SIZE/2);
            
            ctx.restore();
        }
        
        // Disegna la minimappa
        function drawMinimap() {
            const minimapSize = 150;
            const minimapX = canvas.width - minimapSize - 10;
            const minimapY = 10;
            const scale = minimapSize / Math.max(MAP_WIDTH, MAP_HEIGHT);
            
            // Sfondo della minimappa
            ctx.fillStyle = 'rgba(0, 0, 0, 0.8)';
            ctx.fillRect(minimapX, minimapY, minimapSize, minimapSize);
            ctx.strokeStyle = '#ffd700';
            ctx.lineWidth = 2;
            ctx.strokeRect(minimapX, minimapY, minimapSize, minimapSize);
            
            // Disegna la mappa in scala
            for (let y = 0; y < MAP_HEIGHT; y++) {
                for (let x = 0; x < MAP_WIDTH; x++) {
                    if (gameMap[y][x] === CELL_TYPES.FLOOR) {
                        ctx.fillStyle = '#333';
                        ctx.fillRect(
                            minimapX + x * scale,
                            minimapY + y * scale,
                            scale,
                            scale
                        );
                    }
                }
            }
            
            // Disegna le entit√† sulla minimappa
            entities.forEach(entity => {
                if (!entity.solved) {
                    let color = '#fff';
                    switch(entity.type) {
                        case CELL_TYPES.DOOR: color = '#3b82f6'; break;
                        case CELL_TYPES.ENEMY: color = '#ef4444'; break;
                        case CELL_TYPES.TREASURE: color = '#fbbf24'; break;
                        case CELL_TYPES.EXIT: color = '#4ade80'; break;
                    }
                    ctx.fillStyle = color;
                    ctx.fillRect(
                        minimapX + entity.x * scale - 1,
                        minimapY + entity.y * scale - 1,
                        scale + 2,
                        scale + 2
                    );
                }
            });
            
            // Posizione del giocatore
            ctx.fillStyle = player.color;
            ctx.fillRect(
                minimapX + player.x * scale - 2,
                minimapY + player.y * scale - 2,
                scale + 4,
                scale + 4
            );
        }
        
        // Game Over
        function gameOver() {
            gameState.gameRunning = false;
            document.getElementById('gameOverScreen').style.display = 'block';
        }
        
        // Vittoria
        function showVictory() {
            gameState.gameRunning = false;
            document.getElementById('finalLevel').textContent = player.level;
            document.getElementById('finalExp').textContent = player.exp;
            document.getElementById('victoryScreen').style.display = 'block';
        }
        
        // Riavvia il gioco
        function restartGame() {
            // Reset giocatore
            player = {
                x: 1,
                y: 1,
                health: 100,
                maxHealth: 100,
                mana: 50,
                maxMana: 50,
                level: 1,
                exp: 0,
                expToNext: 100,
                color: '#00ffff'
            };
            
            // Reset stato del gioco
            gameState = {
                currentRoom: 1,
                currentEquation: null,
                awaitingAnswer: false,
                gameRunning: true,
                initialized: true
            };
            
            // Nascondi schermate
            document.getElementById('gameOverScreen').style.display = 'none';
            document.getElementById('victoryScreen').style.display = 'none';
            document.getElementById('equationPanel').style.display = 'none';
            
            // Reset messaggi
            document.getElementById('messageLog').innerHTML = `
                <div class="message info">üåü Nuova avventura iniziata!</div>
                <div class="message info">üéÆ Buona fortuna!</div>
            `;
            
            // Rigenera mappa
            generateMap();
            updateUI();
        }
        
        // Gestione input da tastiera
        document.addEventListener('keydown', (e) => {
            if (!gameState.initialized) return;
            
            if (gameState.awaitingAnswer) {
                if (e.key === 'Enter') {
                    checkAnswer();
                }
                return;
            }
            
            switch(e.key.toLowerCase()) {
                case 'w':
                case 'arrowup':
                    e.preventDefault();
                    movePlayer(0, -1);
                    break;
                case 's':
                case 'arrowdown':
                    e.preventDefault();
                    movePlayer(0, 1);
                    break;
                case 'a':
                case 'arrowleft':
                    e.preventDefault();
                    movePlayer(-1, 0);
                    break;
                case 'd':
                case 'arrowright':
                    e.preventDefault();
                    movePlayer(1, 0);
                    break;
                // SPAZIO ora mostra solo un suggerimento
                case ' ':
                    e.preventDefault();
                    checkInteractions();
                    break;
            }
        });
        
        // Game loop
        function gameLoop() {
            if (gameState.gameRunning) {
                draw();
                updateUI();
            }
            requestAnimationFrame(gameLoop);
        }
        
        // Inizializzazione del gioco
        function initGame() {
            console.log('Inizializzazione gioco...');
            loadingScreen.style.display = 'none';
            gameState.initialized = true;
            generateMap();
            updateUI();
            
            // Debug: mostra posizione entit√†
            console.log('Entit√† create:', entities);
            console.log('Posizione giocatore:', {x: player.x, y: player.y});
            
            gameLoop();
            
            addMessage('üéÆ Gioco caricato! Usa WASD o le frecce per muoverti!', 'success');
            addMessage('‚ö° Avvicinati agli oggetti colorati per attivarli automaticamente!', 'info');
            addMessage('üßÆ Non serve premere SPAZIO - basta avvicinarsi!', 'info');
        }
        
        // Avvia il gioco quando tutto √® pronto
        window.addEventListener('load', () => {
            setTimeout(initGame, 500);
        });
    </script>
</body>
</html>unge messaggio al log
        function addMessage(text, type = 'info') {
            const log = document.getElementById('messageLog');
            const message = document.createElement('div');
            message.className = `message ${type}`;
            message.textContent = text;
            log.appendChild(message);
            log.scrollTop = log.scrollHeight;
            
            // Rimuovi messaggi vecchi
            while (log.children.length > 10) {
                log.removeChild(log.firstChild);
            }
        }
        
        // Aggi
